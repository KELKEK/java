<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script>
//1.선언적 함수 ... 이름이 있는 함수
f = function(){};
//2. 익명함수 ... 이름이 없는 함수
var v1 = 300;
v2 = 400;
function call1(){
	document.getElementById("here").innerHTML="변수선언1";
	var a = 100; //함수내에서 var은 지역변수이다.
	b = 200; //var이 없으면 global변수이다.
};
function call2(){
	document.getElementById("here").innerHTML = v1+v2+b;//일단 변수에대하여1을 눌러줘야 한다.
};
function call3(){
	var a = 100, b = 10;
	var result = a >= 100 && ++b > 10;
	document.getElementById("here").innerHTML= result+ "==>" + b;
	//&&는 앞의 결과가 false이면 뒷부분은 수행안함
	//||는 앞의 결과가 true이면 뒷부분은 수행안함
	var result2 = a < 100 && ++b > 10;
	document.getElementById("here").innerHTML += "<br>" + result2+ "==>" + b;
}
function call4(){
	//사용자에게 점수를 입력받아서 90~100 A학점 머시기 하기(80~89)B...(if, switch)
	var score = document.getElementById("score").value;
	if(score >= 90 && score <= 100){
		document.getElementById("here").innerHTML = "A학점";
	}else if(score >= 80 && score < 90){
		document.getElementById("here").innerHTML = "B학점";
	}else if(score >= 70 && score < 80){
		document.getElementById("here").innerHTML = "C학점";
	}else if(score >= 60 && score < 70){
		document.getElementById("here").innerHTML = "D학점";
	}else{
		document.getElementById("here").innerHTML = "F학점";
	}
	
	var grade;
	
	switch(Math.floor(score / 10)){
	case 9:{
		grade = "A";
		break;
	}
	case 9:{
		grade = "B";
		break;
	}
	case 9:{
		grade = "C";
		break;
	}
	case 9:{
		grade = "D";
		break;
	}
	default:{break;}
	}
	document.getElementById("here").innerHTML += grade;
	
	
}
function call5(){
	var su = document.querySelector("#score").value;//#주면 id, .주면 class 방식은 css방식과 같다.
	var total = 0;
	//block 내에서만 유효한 변수(scope) : let
	for(var i = 1; i <= su; i++){
		total += i;
		let k = 50;
	}
	document.getElementById("here").innerHTML = "1~" + su + "까지의 합계" + total;
	console.log("var는 지역변수이다. 지역변수는 함수 내에서 사용가능 : " + i);
	console.log("let는 지역변수이다. 지역변수는 block 밖에서 사용불가능 : " + k);
}

function call6(){
	//``백틱
	var output = "";
	//let을 쓰지 않으면 전역변수가 되어 다른 메서드에도 접근 가능하게 된다.
	for(let gop=2; gop <=9; gop++){
		if(gop==4) break;
		for(let dan = 2; dan <=9; dan++){
			output += `${dan} * ${gop} = ${dan*gop} &nbsp;&nbsp;`;
		}
		output += "<br>";
	}
	document.getElementById("here").innerHTML = output;
}

//console.log(var1); //not defined 오류가 아니다
var js1;//자바스크립트는 var과 function을 맨위로 끌어올린다.(호이스팅)
console.log(js1); //not defined 오류가 아니다
var js1 = 100;
console.log(js1); //잘 찍힘
//함수호출
call7();

//함수정의
function call7(){
	console.log("js2=" + js2);
	var js2 = 200;
	console.log("js2=" + js2);
	alert(js1+js2);
	
	const js3 = 300;
	//js3 = 400; //상수는 값을 바꿀 수 없다.
	
	let js4 = 400;
	js4 = 500;//재할당 가능
	//let js4  = 500; 재선언불가.
	
}
function call8(){
	var result = sum(1,10) + sum(1, 100);
	here.innerHTML = result; //이렇게 해도 되지만 방식 추천 안하심
}
function sum(start, end){
	var total = 0;
	for(let i = start; i <= end; i++){
		total += i;
	}
	return total;
}
//이름이 있는 함수 : 선언적 함수
function call9(){
	//내부함수 : 함수 내의 함수
	function innerFunction(a, b){
		console.log("내부함수 : 이름이 있는 함수" + (a+b));
		return a+b;
	};
	var f0 = innerFunction(30, 60);
	console.log("받은 값 : " + f0);
	
	//익명함수 : 이름이 없는 함수
	var f1 = function(a, b){
		console.log("익명함수 : 이름이 없는 함수 " + (a+b));
		return a+b;
	};
	var result = f1(10,20);//인수를 주고 함수를 호출한 것, 함수의 매개변수가 값을 받는다.
	console.log("받은 값" + result);
	
	//즉시실행함수 -->함수 전체를 관호로 감싼 뒤 진행/변수의 scope 관리에 있어 용이함
	var result2 = (function(a, b){
		console.log("익명함수 : 이름이 없는 함수" + (a+b));
	    return a+b;
	})(30, 40);
	console.log("받은값2:" + result2);
}
</script>
</head>
<body>
<h1>JavaScript연습</h1>
<button  onclick="call1()">변수에 대하여1</button>
<button  onclick="call2()">변수에 대하여2</button>
<button  onclick="call3()">논리연산자</button>
점수 : <input type="number" id="score" value="100">
<button  onclick="call4()">조건문</button>
<button  onclick="call5()">반복문</button>
<button  onclick="call6()">구구단</button>
<button  onclick="call7()">호이스팅</button>
<button  onclick="call8()">return 있는 함수</button>
<button  onclick="call9()">익명함수</button>
<hr>
<div id="here">여기</div>
</body>
</html>